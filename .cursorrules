# Coding conventions

You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Tailwind, Postgres
from Supabase managed with Prisma and authentication with Clerk.

## Code Style and Structure

-   Write concise, technical TypeScript code with accurate examples
-   Use functional and declarative programming patterns; avoid classes
-   Prefer iteration and modularization over code duplication
-   Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
-   Structure files: exported component, subcomponents, helpers, static content, types

## Naming Conventions

-   Use lowercase with dashes for directories (e.g., components/auth-wizard)
-   Favor named exports for components

## TypeScript Usage

-   Use TypeScript for all code; prefer interfaces over types
-   Avoid enums; use maps instead
-   Use functional components with TypeScript interfaces

## Syntax and Formatting

-   Use the "function" keyword for pure functions
-   Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements
-   Use declarative JSX

## UI and Styling

-   Use Shadcn UI, Radix, and Tailwind for components and styling
-   Implement responsive design with Tailwind CSS; use a mobile-first approach

## Performance Optimization

-   Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC)
-   Wrap client components in Suspense with fallback
-   Use dynamic loading for non-critical components
-   Optimize images: use WebP format, include size data, implement lazy loading.

## Tools

-   use `npx shadcn@latest add` to install shadcn components

## TanStack Query Conventions

-   Use TanStack Query for client-side data management and caching
-   Structure query keys hierarchically: [entity, identifier, filters]
-   Place query hooks in /hooks/queries and /hooks/mutations directories
-   Name query hooks with 'use' prefix (e.g., useUsers, useCreateUser)
-   Implement error boundaries for query error handling
-   Use prefetchQuery for known data requirements
-   Set consistent staleTime and gcTime in QueryClient provider
-   Implement optimistic updates for mutations when possible
-   Use suspense mode with Suspense boundaries
-   Keep query logic separate from UI components
-   Avoid direct fetch calls when TanStack Query can be used
-   Handle loading and error states consistently across queries

## Key Conventions

-   Use 'nuqs' for URL search parameter state management
-   Optimize Web Vitals (LCP, CLS, FID)
-   Limit 'use client':
    -   Favor server components and Next.js SSR
    -   Use only for Web API access in small components
    -   Avoid for data fetching or state management
-   Comment everything to make it easy for developers and AI to understand

Follow Next.js docs for Data Fetching, Rendering, and Routing.
